1:dubbo的简单模型，写成博客（优先级别很高）
2:dubbo的面向接口、mybatis的面向接口注入、spring的注入接口，使用接口的方式进行依赖能够将各个程序组件之间的耦合度降低。
3：通用的webservices，可以抽象泛化一个模型出来。
4：我觉得项目中用到的各种组件，我们有必要去列举出来。你懂得。

5：抽时间重构自动化测试项目后台，利用适配层范例，写一个通用的出来。
其实我现在有了一个简单的设计思路，为何这样说呢？
a 首先把自己的需要请求的api的参数放在请求的路径中。（get-post请求随意）
b 得到API名称，利用泛型执行对应的方法。
6：dubbo的consumer端依赖的都是接口，但是dubbo的是可以在接口的配置中配置一个接口实际的实现的，故而对于我们来说，consumer和provider之间通信就使用的是接口相互依赖。
7：在容器启动的时候，spring就会扫描得到xml文件中配置的所有bean。
8：springBeanUtils原理看一下，是否与spring框架本身耦合就是对的呢？

9：得到了非常有教育意义的一个例子，那就是注解和xml文件并的用时候一定要小心。



我在controller里面引入了service，我以为这个service在我请求的时候就会自动注入需要的属性，事实上也确实如此，但是我很尴尬的在xml文件中也定义了这个service，那么，spring在自动注入的时候注入的是xml文件中定义的，因为它初始化早，当我去掉xml文件中的定义的时候，我发现一切如我所预期的那样，跑的十分顺畅。                                                                                                                                                                                                                        
10：你想拥有让自己定义的类能够实现方法级别的拦截吗？让你写的类继承MethodInterceptor即可。        

12:这个缓存尤其是aop的切入这一块设计的太精妙，难道是我太弱！      
数据库都有连接池的概念，那么redis一定也对应的会有redis的连接池。   

13：我在思考一个问题，springmvc和ioc维护的是一个容器吗？也就是说，这两个容器间注入的bean是可以相互共享的吗？   
其实针对于这样的一个问题我们可以做一个简单的实验，怎么说呢？通过这个简单的实验，我发现他们维护的并不是一套，甚至可以说是隔离的
1：首先在servlet-mvc.xml中配置自动扫描service包，这个时候有注解的类就会注入到spring-mvc的容器管理中去，但是你用applicationContext是拿不到这个类的引用的。
说明了啥，说明他们两个其实是分开的。
这也就不难解释前天我遇到的问题，那就是：	
我在applicationContext.xml文件中配置了一个bean，这个controller自动注入了这个类，当然，这个bean里面我又采取了注解的方式，但是来扫描这个注解的不是applicationContext.xml，而是servlet-mvc.xml，你懂得，于是service层里面的一些成员变量就总是报空指针异常，当时我还以为是xml和注解混用导致的问题，现在终于知道，原来是有两套管理对象的东西。
http://yjph83.iteye.com/blog/2302120

当我使用
绝对的好文章！
14：methodinterctor


15：jstl表达式的支持需要web.xml文件中web容器配置到版本2.5及以上。                                                                                                             
16：从东哥处吸取到了一个新的知识点：
就是我们在服务化的过程中，依赖client，这个时候我们扫描所有的classpath下面的所有xml文件，我们是可以扫描到我们依赖的项目的classpath的。                                

17：一直对于线程池的作用其实不是很理解，但是后来才发现，其实线程池真的很重要。

比如说：

它可以有效地调度资源，也可以限制创建的线程多少。

你知道的，多线程的条件下我们可能会面临资源过度消耗的问题。

而且我还需要你分析一下为啥线程不是越多越好？

这是一个独立的博客

看了一下线程池的配置，发现我们的线程池在配置出来以后还是需要我们去获取其实例得到线程，
我一直以为线程池是针对于我们的controller的，看来是我愚蠢了
呵呵

原来这个是让我们在执行异步任务的时候能够更好的管理线程。

18：
threadpool为了专门处理多线程问题而提出来的一个类。
	

我现在在想一个问题：

这个东西其实一般都是需要异步的。

这里的线程池会影响正常的web请求吗？


19：从宁哥哪里get到的技能，也不算是get到的技能吧，就是成员变量是线程间共享的，而局部变量是线程独立的。你懂得。
故而需要思考一下。


20：spring mvc 和struts2的对比也很有趣。

21:spring中bean的name属性和id属性其实是一样的，不过是id属性是不能出现特殊字符的，比如/loginin




