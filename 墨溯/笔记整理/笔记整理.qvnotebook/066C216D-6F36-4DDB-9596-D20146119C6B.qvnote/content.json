{
  "title": "我的阶段性技术总结",
  "cells": [
    {
      "type": "markdown",
      "data": "### 我是一个后端\n### 技术栈\n内功\n外功\n项目管理\n\n资源-》评估系统的负载-》负载增加的时候我们如何做？\n通常我们会基于两个维度：\n1、负载增加的时候，我们的系统资源不变，观察系统的负载变化\n2、负载不变的时候，资源减少等\n\n所以说最科学的方式就是对比参照，同期数据的对比参照\n压测也是实际搞清楚负载的一个过程\n\n我们手里的资源有什么？\n1、ECS-》网络 磁盘 CPU 内存 线程 计算资源 Docker配置 JVM等等\n2、存储硬盘 内存 分布式缓存等等 缓存的意义 提前计算的意义 等等\n3、网络入口统一接入 Tengine等等 \n4、代码\n5、CDN等外部工具 Linux使用等\n6、外部工具 ealgaee arthas sunfire psp运维工具等等\n\n函数式编程\n单元测试-》编写可测试的代码（脱离复杂的mock工具）\n微基准测试，关注一些调用量十分可观的方法的耗时及CPU占用情况\nCPU压力分析\nTOP指令等等\n高阶函数，从函数级别复用代码\n状态变化转为函数的返回值\n依赖全局数据修改为函数参数\n函数的组合以及拆解 科里化\n\n对业务代码进行分析\n流程性代码\n业务代码-》需要做好测试，十分复杂\n即使是一行代码，有明确的业务意义，也应该剥离\n\n\n#### 异步浅谈\n线程的定义\njava线程模型\n异步 同步 阻塞 非阻塞 含义\n\njava中的异步编程\nThread 模式\nCallable模式 有返回值 和发起调用的县城实现数据的交互\nFuture模式支持等待，获取目前的执行状态\n基于Guava的扩展，支持回调的future模式\njdk8的CompletableFuture 模式\nForkJoin Pool的并行流等\nGo语言的异步模式\nNode的异步模式，如何解决多层回调等等\n\n多范式编程，我们要思考每一种范式的优势和劣势\n\n### 分布式浅谈\n讨论分布式的时候我们在讨论什么\n分库分表吗\n\n外功\n架构决策\n对业务的理解，比如说店铺存在的意义是？我们在业务的角度来分析，店铺作为商家自己的私域，支持商家自己的功能，商家的店铺的流量取决于自己的运营效果。\n店铺是一个集合，提供了基础能力，但是诸如买家秀、直播、商品之类的数据集合均是我们需要考虑的\n如何让店铺有更多的玩法，\n一个是借鉴传统的店铺的玩法，如何铺货、如何进行店铺的规划布局、流量导入等等\n一个是借助技术的实现等等\n\n做店铺我们到底在做什么？\nPDCA 理论\n系统的演进与迭代等等\n\n\n\n但是很多数据都要在店铺透出，\n导购链路等等\n\n网络的布局，网络单元化的流量分配，容量的评估\n\n1、容易被引导\n2、擅长学习\n3、善于总结\n\n1、关注对错\n2、关注利弊\n3、关注整体和平衡\n\n1、成群化\n2、个体化\n3、孤独的\n\n关于系统负载的思考：\n1、系统的负载如何评判，只是来源于RT以及QPS，网络流量已经句柄文件数\n站在Linux的角度来看的话，应该如何做好处理\n\n2、95线 99线 以及 999 线反应的指标是什么?\n长尾效应如何理解？\n样本数不足？\n\n3、系统负载增大之后的扩展以及改进。如何在写代码的时候就规避一些低级的错误，或者说能够充分的利用我们手上的资源。\nECS的内存型机器及计算型机器为何无法普及，我们使用的为何都是标准型的机器。\n\n\n4、机器的预热、数据的预热、衰减等等\n\n\n- 单元化的背景\n- 哪些系统的单元化\n- 单元化流量分配等\n- 导购单元&交易单元\n- 单元流量分配\n\n抽象和分层\n其实是非常重要的\n\nLinux的服务器\n- 指令\n  - grep 显示匹配行的前后几行\n  - -n 展示行号\n  - sed -n '100,200p' filename 查看一个文件的100-200行\n  - sed -n \"/Exception/p\" application.log 在文件中查找匹配到Exception的行\n  - tail \n  - cat\n  - head \n  - more \n  - less\n- 磁盘挂载\n\n\n### 内部类的专题\n- 内部类的存在\n  - 1、可以解决数据结构的问题，当有一个类和另一个类在JSON的结构上存在层属关系的时候\n  - 2、此类只会被外部类使用，此时应该定义为内部类等。\n  - 3、除此之外，实际我们还需要知道，内部类的\n\n\n\n\n\n\n\n迁移的URL\n\n\n\nLRU算法实现\n\n网络的相关问题：\nJVM STW，导致采集数据agent迟迟不ack，导致TCP重传率放大。\nNginx代理80端口，即使后面的应用服务器ack不及时，但是依旧可以不会大量重传。\n\n面对性能优化，我们需要有两方面的意识，首先是宏观，其次是微观。\n举例子来说：我们在基本的微观层面\n\nmxBean在做一些基本的JVM信息的获取以及管理方面非常有用\n\n比如我们可以统计HotMethod，就使用mxbeanThread去做统计，我们就可以知道CPU的时间到底都用在了哪里？其次，我们还可以统计啥\n统计\n\n\n最近我在思考基础学科对我们个人塑造的作用，比如物理、数学对我们工程师的重要性。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    }
  ]
}